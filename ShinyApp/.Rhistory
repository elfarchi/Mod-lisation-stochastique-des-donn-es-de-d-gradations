main = "QQ-plot des read (filles)",
col="red")
qqline(pisa$read[pisa$gender == "female"])
# Tests de normalité
shapiro.test(pisa$read[pisa$gender == "male"])
shapiro.test(pisa$read[pisa$gender == "female"])
# Intervalle de confiance bootstrap
IC <- quantile(ab_values, probs =  c(0.025, 0.975))
cat("L'intervalle de confiance est ainsi [", round(IC[1], 2), ";", round(IC[2], 2), "]")
# Intervalle de confiance bootstrap
IC <- quantile(ab_values, probs =  c(0.025, 0.975))
cat("L'intervalle de confiance est ainsi [", round(IC[1], 2), ";", round(IC[2], 2), "]")
# Intervalle de confiance bootstrap
IC <- quantile(ab_values, probs =  c(0.025, 0.975))
cat("L'intervalle de confiance est ainsi [", round(IC[1], 2), ";", round(IC[2], 2), "]")
# Intervalle de confiance bootstrap
IC <- quantile(ab_values, prob =  c(0.025, 0.975))
cat("L'intervalle de confiance est ainsi [", round(IC[1], 2), ";", round(IC[2], 2), "]")
# Intervalle de confiance bootstrap
IC <- quantile(ab_values, prob =  c(0.025, 0.975))
cat("L'intervalle de confiance est ainsi [", round(IC[1], 2), ";", round(IC[2], 2), "]")
IC
IC[1]
B <- 5000                     # nombre de réplications bootstrap
ab_values <- numeric(B)
for (i in 1:B) {
# Tirage bootstrap
sample_idx <- sample(1:nrow(pisa), replace = TRUE)
data_b <- pisa[sample_idx, ]
# Modèle médiateur M ~ X
mod_M_b <- lm(read ~ gender, data = data_b)
# Modèle Y ~ M + X
mod_Y2_b <- lm(math ~ gender + read, data = data_b)
# Extraction des coefficients
a_b <- coef(mod_M_b)[2]
b_b <- coef(mod_Y2_b)[2]
ab_values[i] <- a_b * b_b   # effet indirect bootstrap
}
# Intervalle de confiance bootstrap
IC <- quantile(ab_values, prob =  c(0.025, 0.975))
cat("L'intervalle de confiance est ainsi [", round(IC[1], 2), ";", round(IC[2], 2), "]")
# Intervalle de confiance bootstrap
IC <- quantile(ab_values,  c(0.025, 0.975))
cat("L'intervalle de confiance est ainsi [", round(IC[1], 2), ";", round(IC[2], 2), "]")
# Intervalle de confiance bootstrap
IC <- quantile(ab_values,  c(0.025, 0.975))
cat("L'intervalle de confiance est ainsi [", round(IC[1], 2), ";", round(IC[2], 2), "]")
# Intervalle de confiance bootstrap
IC <- quantile(ab_values,  c(0.025, 0.975))
cat("L'intervalle de confiance est ainsi [", round(IC[1], 2), ";", round(IC[2], 2), "]")
# Intervalle de confiance bootstrap
IC <- quantile(ab_values,  c(0.025, 0.975))
cat("L'intervalle de confiance est ainsi [", round(IC[1], 2), ";", round(IC[2], 2), "]")
PISA2018 <- read.csv("./data/PISA2018subset.csv", stringsAsFactors = TRUE)
# Sélection des pays d’Europe de l’Ouest
pisa <- subset(PISA2018, country %in% c("FRA", "DEU", "BEL", "ITA", "GBR"))
# Sélection des variables d’intérêt
pisa <- pisa[, c("country", "gender", "read", "math", "escs")]
# Suppression des observations avec valeurs manquantes
pisa <- pisa[!(is.na(pisa$read) | is.na(pisa$escs)),]
# Réduction des niveaux de facteur
pisa$country <- droplevels(pisa$country)
head(pisa)
# Presentation des donnees
plot(pisa$read, pisa$math,
cex = .9, col = "red", pch = 19, las = 1,
xlab = "Scores en lecture",
ylab = "Scores en mathématiques",
main = "Relation entre lecture et mathématiques")
# Ajustement du modele de regression lineaire
mod_math_read = lm(math ~ read, data = pisa)
# Résumé du modèle
summary(mod_math_read)
residus = residuals(mod_math_read)
# Histogramme des résidus
hist(residus, main = "Histogramme des résidus", col = "pink")
# QQ-plot
qqnorm(residus)
qqline(residus)
# Defintions
y = pisa$math
x = pisa$read
r.squared = round((cov(x, y)^2)/(var(x)*var(y)), 2)
cat("La part de variance de `math` expliquée par `read` est : ", r.squared, "\n")
cat("Le resume indique que c'est : ", round(summary(mod_math_read)$r.squared, 2), "\n")
# Presentation des donnees
plot(pisa$read, pisa$math,
cex = .9, col = "red", pch = 19, las = 1,
xlab = "Scores en lecture",
ylab = "Scores en mathématiques",
main = "Relation entre lecture et mathématiques")
legend(x = "topleft",
legend = paste("Droite de régression linéaire (R2 = ", r.squared*100, "%)"))
# Droite de tendance
abline(mod_math_read, col = "blue")
b_1 = round(coef(mod_math_read)[2], 2)
b_1_hat = round(cov(x, y)/var(x), 2)
cat("Theoriquement la pente est ", b_1_hat, "\n")
cat("Le resume indique que c'est : ", b_1, "\n")
cat("Leur score moyen en mathématiques sera supérieur à la moyenne générale de : ",
round(b_1 * 10, 2), "points\n")
IC_sup = round(confint(mod_math_read)[2, 2], 2)
IC_inf = round(confint(mod_math_read)[2, 1], 2)
cat("l’intervalle de confiance à 95 % de l’estimation de la pente de la droite \n",
"de régression est : [", IC_inf, "; ", IC_sup, "]\n")
cat("la p-valeur associée au test de significativité de ce coefficient est : ",
coef(summary(mod_math_read))[2, 4], "\n")
b_confusion = round(coef(lm(pisa$math ~ pisa$read + pisa$escs))[3]
* cor(pisa$escs, pisa$read)
* sd(pisa$escs)/sd(pisa$read)
, 2)
cat("Le biais de confusion =", b_confusion, " est non nul\n")
cat("`math` et `escs` ont une correlation de ",
round(cor(pisa$math, pisa$escs), 2), "\n")
cat("L'effet de `escs` sur `math` est ",
round(coef(lm(pisa$math ~ pisa$read + pisa$escs))[3], 2), "\n")
mod_read_et_escs = lm(pisa$math ~ pisa$read + pisa$escs)
b_1 = coef(mod_read_et_escs)[2]
a_1 = coef(mod_math_read)[2]
cat("1) L'effet partiel de `read` sur `math` une fois `escs` pris en compte est ",
b_1, "\n")
cat("2) L'effet partiel de `read` sur `math` sans prise en compte de `escs` est ",
a_1, "\n")
cat("Le bias de confusion est donc ", round(a_1 - b_1, 2), "\n")
cat("La moyenne des scores en `math` est 500, ainsi le biais de confusion est faible.")
# 1. Boxplot des scores en math selon le sexe
boxplot(math~gender, data = pisa, col = c("pink", "lightblue"))
### 2. Vérification de la normalité par QQ-plot
par(mfrow = c(1,2))  # pour afficher les 2 graphiques côte à côte
# Males
qqnorm(pisa$math[pisa$gender == "male"],
main = "QQ-plot des math (garçons)",
col="blue")
qqline(pisa$math[pisa$gender == "male"])
# Females
qqnorm(pisa$math[pisa$gender == "female"],
main = "QQ-plot des math (filles)",
col="red")
qqline(pisa$math[pisa$gender == "female"])
# Tests de normalité
shapiro.test(pisa$math[pisa$gender == "male"])
shapiro.test(pisa$math[pisa$gender == "female"])
t.test(pisa$math[pisa$gender == "male"], pisa$math[pisa$gender == "female"],
alternative = "two.sided")
# 1. Boxplot des scores en math selon le sexe
boxplot(read~gender, data = pisa, col = c("pink", "lightblue"))
### 2. Vérification de la normalité par QQ-plot
par(mfrow = c(1,2))  # pour afficher les 2 graphiques côte à côte
# Males
qqnorm(pisa$read[pisa$gender == "male"],
main = "QQ-plot des read (garçons)",
col="blue")
qqline(pisa$read[pisa$gender == "male"])
# Females
qqnorm(pisa$read[pisa$gender == "female"],
main = "QQ-plot des read (filles)",
col="red")
qqline(pisa$read[pisa$gender == "female"])
# Tests de normalité
shapiro.test(pisa$read[pisa$gender == "male"])
shapiro.test(pisa$read[pisa$gender == "female"])
t.test(pisa$read[pisa$gender == "male"], pisa$read[pisa$gender == "female"],
alternative = "two.sided")
mod_M = lm(read ~ gender, data = pisa)
mod_Y2 = lm(math ~ read + gender, data = pisa)
mod_Y = lm(math ~ gender, data = pisa)
a = coef(mod_M)[2]
b = coef(mod_Y2)[2]
c = coef(mod_Y2)[3]
d = coef(mod_Y)[2]
cat("L’effet direct c est ", round(c, 2), "\n")
cat("L’effet indirect ab est ", round(a * b, 2), "\n")
cat("On a bien d = ab + c =", round(d, 2), "\n")
cat("la p-valeur sur le test de l'effet direct est ",
coef(summary(mod_Y2))[3, 4],
"< 0.05\n")
cat("Les valeurs plausibles de l’effet direct se situent entre [",
round(confint(mod_Y2)["gendermale", 1], 2),
";",
round(confint(mod_Y2)["gendermale", 2], 2),
"]\n")
B <- 5000                     # nombre de réplications bootstrap
ab_values <- numeric(B)
for (i in 1:B) {
# Tirage bootstrap
sample_idx <- sample(1:nrow(pisa), replace = TRUE)
data_b <- pisa[sample_idx, ]
# Modèle médiateur M ~ X
mod_M_b <- lm(read ~ gender, data = data_b)
# Modèle Y ~ M + X
mod_Y2_b <- lm(math ~ read + gender, data = data_b)
# Extraction des coefficients
a_b <- coef(mod_M_b)[2]
b_b <- coef(mod_Y2_b)[2]
ab_values[i] <- a_b * b_b   # effet indirect bootstrap
}
# Intervalle de confiance bootstrap
IC <- quantile(ab_values,  c(0.025, 0.975))
cat("L'intervalle de confiance est ainsi [", round(IC[1], 2), ";", round(IC[2], 2), "]")
install.packages("shiny")
library(shiny)
runExample("01_hello")
shiny::runApp('Desktop/equipe_1/ShinyApp')
runApp('Desktop/equipe_1/ShinyApp')
runApp('Desktop/equipe_1/ShinyApp')
runApp('Desktop/equipe_1/ShinyApp')
runApp('Desktop/equipe_1/ShinyApp')
runApp('Desktop/equipe_1/ShinyApp')
runApp('Desktop/equipe_1/ShinyApp')
runApp('Desktop/equipe_1/ShinyApp')
source('/home/zeroualima/Desktop/equipe_1/ShinyApp/app.R')
runApp('Desktop/equipe_1/ShinyApp')
runApp('Desktop/equipe_1/ShinyApp')
help(plot)
runApp('Desktop/equipe_1/ShinyApp')
runApp('Desktop/equipe_1/ShinyApp')
runApp('Desktop/equipe_1/ShinyApp')
runApp('Desktop/equipe_1/ShinyApp')
runApp('Desktop/equipe_1/ShinyApp')
shiny::runApp('Desktop/equipe_1/ShinyApp')
shiny::runApp('Desktop/equipe_1/ShinyApp')
runApp('Desktop/equipe_1/ShinyApp')
runApp('Desktop/equipe_1/ShinyApp')
runApp('Desktop/equipe_1/ShinyApp')
shiny::runApp('Desktop/equipe_1/ShinyApp')
runApp('Desktop/equipe_1/ShinyApp')
runApp('Desktop/equipe_1/ShinyApp')
df <- read.csv2("/home/elfarchi/equipe_1/Laser.csv")
source("~/Desktop/equipe_1/ShinyApp/sim traj weiner semi_cond.R")
source("~/Desktop/equipe_1/ShinyApp/sim traj weiner semi_cond.R")
source("~/Desktop/equipe_1/ShinyApp/sim traj weiner semi_cond.R")
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
runApp('Desktop/equipe_1/ShinyApp')
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
runApp('Desktop/equipe_1/ShinyApp')
output$csv_stats <- renderPrint({
req(input$show_stats)
df <- data()
t = df[, 1]
a = numeric(ncol(df) - 1)
b = numeric(ncol(df) - 1)
for (i in 1:length(a)) {
X = df[, i + 1]
delta_X = numeric(nrow(df))
delta_X[1] = X[1]
for (j in 2:length(delta_X)) {
delta_X[i] = X[i] - X[i - 1]
}
m = mean(delta_X)
v = variance(delta_X)
a[i] = m/v
b[i] = t[length(t)]/v
}
print(a)
runApp('Desktop/equipe_1/ShinyApp')
runApp('Desktop/equipe_1/ShinyApp')
cg
c
for (i in 1:length(a)) {
X = df[, i + 1]
delta_X = numeric(nrow(df))
delta_X[1] = X[1]
for (j in 2:length(delta_X)) {
delta_X[i] = X[i] - X[i - 1]
}
m = mean(delta_X)
v = variance(delta_X)
a[i] = m/v
b[i] = t[length(t)]/v
}
jbfdce
shiny::runApp('Desktop/equipe_1/ShinyApp')
shiny::runApp('Desktop/equipe_1/ShinyApp')
shiny::runApp('Desktop/equipe_1/ShinyApp')
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
runApp('Desktop/equipe_1/ShinyApp')
library(shiny); runApp('Desktop/equipe_1/ShinyApp/app_test.R')
library(shiny); runApp('Desktop/equipe_1/ShinyApp/app_test.R')
runApp('Desktop/equipe_1/ShinyApp/app_mod.R')
runApp('Desktop/equipe_1/ShinyApp')
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
source("~/Desktop/equipe_1/ShinyApp/plusieurs trajectoires.R")
source("~/Desktop/equipe_1/ShinyApp/plusieurs trajectoires.R")
source("~/Desktop/equipe_1/ShinyApp/plusieurs trajectoires.R")
source("~/Desktop/equipe_1/ShinyApp/plusieurs trajectoires.R")
source("~/Desktop/equipe_1/ShinyApp/plusieurs trajectoires.R")
source("~/Desktop/equipe_1/ShinyApp/plusieurs trajectoires.R")
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
source("~/Desktop/equipe_1/ShinyApp/simulation_gamma _moments.R")
source("~/Desktop/equipe_1/ShinyApp/estimation gamma.R")
source("~/Desktop/equipe_1/ShinyApp/estimation gamma.R")
source("~/Desktop/equipe_1/ShinyApp/estimation gamma.R")
source("~/Desktop/equipe_1/ShinyApp/estimation gamma.R")
source("~/Desktop/equipe_1/ShinyApp/estimation gamma.R")
source("~/Desktop/equipe_1/ShinyApp/estimation gamma.R")
source("~/Desktop/equipe_1/ShinyApp/estimation gamma.R")
source("~/Desktop/equipe_1/ShinyApp/estimation gamma.R")
runApp('Desktop/equipe_1/ShinyApp')
source("~/Desktop/equipe_1/ShinyApp/estimation gamma.R")
runApp('Desktop/equipe_1/ShinyApp')
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
source("~/Desktop/equipe_1/ShinyApp/estimation gamma.R")
source("~/Desktop/equipe_1/ShinyApp/estimation gamma.R")
source("~/Desktop/equipe_1/ShinyApp/estimation gamma.R")
source("~/Desktop/equipe_1/ShinyApp/estimation gamma.R")
source("~/Desktop/equipe_1/ShinyApp/simulation_weiner_moments.R")
runApp('Desktop/equipe_1/ShinyApp')
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
source("~/Desktop/equipe_1/ShinyApp/simulation_weiner_moments.R")
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
source("~/Desktop/equipe_1/ShinyApp/plusieurs trajectoires.R")
source("~/Desktop/equipe_1/ShinyApp/sim traj weiner semi_cond.R")
source("~/Desktop/equipe_1/ShinyApp/sim traj weiner semi_cond.R")
source("~/Desktop/equipe_1/ShinyApp/plusieurs trajectoires.R")
source("~/Desktop/equipe_1/ShinyApp/sim traj weiner semi_cond.R")
runApp('Desktop/equipe_1/ShinyApp')
runApp('Desktop/equipe_1/ShinyApp')
shiny::runApp('Desktop/equipe_1/ShinyApp')
runApp('Desktop/equipe_1/ShinyApp')
shiny::runApp('Desktop/equipe_1/ShinyApp')
mu = 1
sigma = 1
simulateWiener = function(N, nbr_pts, mu, sigma, t) {
Z = rnorm(N)          # Coefficients aléatoires
B = rep(0, nbr_pts)            # Stockage du bruit brownien approché
for (i in 1:nbr_pts){
s <- 0
# Décomposition de Karhunen-Loève tronquée
for(j in 1:N){
e = sqrt(8*T)/((2*j+1)*pi)*sin(((2*j+1)*pi*t[i])/(2*T))
s <- s + Z[j]*e
}
B[i] = s
}
# Processus avec dérive : X(t) = μt + σB(t)
X = mu*t + sigma*B
return(X)
}
t = seq(0, 10, nbr_pts)
plot(t, simulateWiener(N, L, mu, sigma, t), type='l')
mu = 1
sigma = 1
nbr_pts = 1000
mu = 1
sigma = 1
nbr_pts = 1000
simulateWiener = function(N, nbr_pts, mu, sigma, t) {
Z = rnorm(N)          # Coefficients aléatoires
B = rep(0, nbr_pts)            # Stockage du bruit brownien approché
for (i in 1:nbr_pts){
s <- 0
# Décomposition de Karhunen-Loève tronquée
for(j in 1:N){
e = sqrt(8*T)/((2*j+1)*pi)*sin(((2*j+1)*pi*t[i])/(2*T))
s <- s + Z[j]*e
}
B[i] = s
}
# Processus avec dérive : X(t) = μt + σB(t)
X = mu*t + sigma*B
return(X)
}
t = seq(0, 10, nbr_pts)
plot(t, simulateWiener(1000, nbr_pts, mu, sigma, t), type='l')
t = seq(0, 10, nbr_pts)
length(t)
plot(t, simulateWiener(1000, nbr_pts, mu, sigma, t), type='l')
t = seq(0, 10, length.out = nbr_pts)
length(t)
plot(t, simulateWiener(1000, nbr_pts, mu, sigma, t), type='l')
t = seq(0, 10, length.out = nbr_pts)
plot(t, simulateWiener(1000, nbr_pts, mu, sigma, t), type='l')
mu = 10
sigma = 1
nbr_pts = 1000
simulateWiener = function(N, nbr_pts, mu, sigma, t) {
Z = rnorm(N)          # Coefficients aléatoires
B = rep(0, nbr_pts)            # Stockage du bruit brownien approché
for (i in 1:nbr_pts){
s <- 0
# Décomposition de Karhunen-Loève tronquée
for(j in 1:N){
e = sqrt(8*T)/((2*j+1)*pi)*sin(((2*j+1)*pi*t[i])/(2*T))
s <- s + Z[j]*e
}
B[i] = s
}
# Processus avec dérive : X(t) = μt + σB(t)
X = mu*t + sigma*B
return(X)
}
t = seq(0, 10, length.out = nbr_pts)
plot(t, simulateWiener(1000, nbr_pts, mu, sigma, t), type='l')
mu = 4
sigma = 1
nbr_pts = 1000
simulateWiener = function(N, nbr_pts, mu, sigma, t) {
Z = rnorm(N)          # Coefficients aléatoires
B = rep(0, nbr_pts)            # Stockage du bruit brownien approché
for (i in 1:nbr_pts){
s <- 0
# Décomposition de Karhunen-Loève tronquée
for(j in 1:N){
e = sqrt(8*T)/((2*j+1)*pi)*sin(((2*j+1)*pi*t[i])/(2*T))
s <- s + Z[j]*e
}
B[i] = s
}
# Processus avec dérive : X(t) = μt + σB(t)
X = mu*t + sigma*B
return(X)
}
t = seq(0, 10, length.out = nbr_pts)
plot(t, simulateWiener(1000, nbr_pts, mu, sigma, t), type='l')
mu = 4
sigma = 1
nbr_pts = 1000
N = 1000
alpha = 0.5
L = 30
h = 20
t = seq(0, 10, length.out = nbr_pts)
Z = rnorm(N)
B = rep(0, nbr_pts)
for (i in 1:nbr_pts){
s <- 0
for(j in 1:N){
e = sqrt(8*T)/((2*j+1)*pi)*sin(((2*j+1)*pi*t[i])/(2*T))
s <- s + Z[j]*e
}
B[i] = s
}
X = mu*t + sigma*B
plot(t, X, type='l')
# =====================
# Model parameters
# =====================
L <- 10.0        # failure threshold
h <- 6.0         # maintenance threshold
a <- 0.5         # reduction factor (0 < a < 1)
mu <- 4.0        # drift
sigma <- 0.5     # volatility
dt <- 0.001      # time step
T_inspect <- 0.1 # inspection period
Nmax <- 5e6      # numerical safety
# =====================
# Initialization
# =====================
X <- numeric()
t <- numeric()
X[1] <- 0.0
t[1] <- 0.0
X_M <- numeric()   # states before maintenance
t_M <- numeric()   # maintenance times
next_inspection <- T_inspect
n <- 1
# =====================
# Simulation
# =====================
while (X[n] < L && n < Nmax) {
# Brownian increment
dB <- sqrt(dt) * rnorm(1)
# Wiener evolution
X_new <- X[n] + mu * dt + sigma * dB
t_new <- t[n] + dt
# Failure: stop immediately
if (X_new >= L) {
X[n + 1] <- X_new
t[n + 1] <- t_new
break
}
# Periodic inspection
if (t_new >= next_inspection) {
if (X_new >= h) {
t_M <- c(t_M, t_new)
X_M <- c(X_M, X_new)
X_new <- a * X_new   # imperfect maintenance (state reduction)
}
next_inspection <- next_inspection + T_inspect
}
# Store
X[n + 1] <- X_new
t[n + 1] <- t_new
n <- n + 1
}
# =====================
# Visualization
# =====================
plot(t, X, type = "l", lwd = 2,
xlab = "Time", ylab = "State X(t)",
main = "Wiener Process with Imperfect Maintenance")
abline(h = h, lty = 2)
abline(h = L, lty = 2)
if (length(t_M) > 0) {
points(t_M, X_M, col = "red", pch = 16)
}
library(shiny); runApp('Desktop/equipe_1/ShinyApp/app_mod.R')
