# Intervalle de confiance percentile
IC <- quantile(ab_values, prob =  c(0.025, 0.975))
IC
# Intervalle de confiance percentile
IC <- quantile(ab_values, probs =  c(0.025, 0.975))
IC
# Intervalle de confiance bootstrap
IC <- quantile(ab_values, probs =  c(0.025, 0.975))
cat("L'intervalle de confiance est ainsi [", IC[1], ";", IC[2], "]")
# Intervalle de confiance bootstrap
IC <- quantile(ab_values, probs =  c(0.025, 0.975))
cat("L'intervalle de confiance est ainsi [", round(IC[1], 2), ";", round(IC[2], 2), "]")
# Intervalle de confiance bootstrap
IC <- quantile(ab_values, probs =  c(0.025, 0.975))
cat("L'intervalle de confiance est ainsi [", round(IC[1], 2), ";", round(IC[2], 2), "]")
PISA2018 <- read.csv("./data/PISA2018subset.csv", stringsAsFactors = TRUE)
# Sélection des pays d’Europe de l’Ouest
pisa <- subset(PISA2018, country %in% c("FRA", "DEU", "BEL", "ITA", "GBR"))
# Sélection des variables d’intérêt
pisa <- pisa[, c("country", "gender", "read", "math", "escs")]
# Suppression des observations avec valeurs manquantes
pisa <- pisa[!(is.na(pisa$read) | is.na(pisa$escs)),]
# Réduction des niveaux de facteur
pisa$country <- droplevels(pisa$country)
head(pisa)
# Presentation des donnees
plot(pisa$read, pisa$math,
cex = .9, col = "red", pch = 19, las = 1,
xlab = "Scores en lecture",
ylab = "Scores en mathématiques",
main = "Relation entre lecture et mathématiques")
# Ajustement du modele de regression lineaire
mod_math_read = lm(math ~ read, data = pisa)
# Résumé du modèle
summary(mod_math_read)
residus = residuals(mod_math_read)
# Histogramme des résidus
hist(residus, main = "Histogramme des résidus", col = "pink")
# QQ-plot
qqnorm(residus)
qqline(residus)
# Defintions
y = pisa$math
x = pisa$read
r.squared = round((cov(x, y)^2)/(var(x)*var(y)), 2)
cat("La part de variance de `math` expliquée par `read` est : ", r.squared, "\n")
cat("Le resume indique que c'est : ", round(summary(mod_math_read)$r.squared, 2), "\n")
# Presentation des donnees
plot(pisa$read, pisa$math,
cex = .9, col = "red", pch = 19, las = 1,
xlab = "Scores en lecture",
ylab = "Scores en mathématiques",
main = "Relation entre lecture et mathématiques")
legend(x = "topleft",
legend = paste("Droite de régression linéaire (R2 = ", r.squared*100, "%)"))
# Droite de tendance
abline(mod_math_read, col = "blue")
b_1 = round(coef(mod_math_read)[2], 2)
b_1_hat = round(cov(x, y)/var(x), 2)
cat("Theoriquement la pente est ", b_1_hat, "\n")
cat("Le resume indique que c'est : ", b_1, "\n")
cat("Leur score moyen en mathématiques sera supérieur à la moyenne générale de : ",
round(b_1 * 10, 2), "points\n")
IC_sup = round(confint(mod_math_read)[2, 2], 2)
IC_inf = round(confint(mod_math_read)[2, 1], 2)
cat("l’intervalle de confiance à 95 % de l’estimation de la pente de la droite \n",
"de régression est : [", IC_inf, "; ", IC_sup, "]\n")
cat("la p-valeur associée au test de significativité de ce coefficient est : ",
coef(summary(mod_math_read))[2, 4], "\n")
b_confusion = round(coef(lm(pisa$math ~ pisa$read + pisa$escs))[3]
* cor(pisa$escs, pisa$read)
* sd(pisa$escs)/sd(pisa$read)
, 2)
cat("Le biais de confusion =", b_confusion, " est non nul\n")
cat("`math` et `escs` ont une correlation de ",
round(cor(pisa$math, pisa$escs), 2), "\n")
cat("L'effet de `escs` sur `math` est ",
round(coef(lm(pisa$math ~ pisa$read + pisa$escs))[3], 2), "\n")
mod_read_et_escs = lm(pisa$math ~ pisa$read + pisa$escs)
b_1 = coef(mod_read_et_escs)[2]
a_1 = coef(mod_math_read)[2]
cat("1) L'effet partiel de `read` sur `math` une fois `escs` pris en compte est ",
b_1, "\n")
cat("2) L'effet partiel de `read` sur `math` sans prise en compte de `escs` est ",
a_1, "\n")
cat("Le bias de confusion est donc ", round(a_1 - b_1, 2), "\n")
cat("La moyenne des scores en `math` est 500, ainsi le biais de confusion est faible.")
# 1. Boxplot des scores en math selon le sexe
boxplot(math~gender, data = pisa, col = c("pink", "lightblue"))
### 2. Vérification de la normalité par QQ-plot
par(mfrow = c(1,2))  # pour afficher les 2 graphiques côte à côte
# Males
qqnorm(pisa$math[pisa$gender == "male"],
main = "QQ-plot des math (garçons)")
qqline(pisa$math[pisa$gender == "male"])
# Females
qqnorm(pisa$math[pisa$gender == "female"],
main = "QQ-plot des math (filles)")
qqline(pisa$math[pisa$gender == "female"])
# Tests de normalité
shapiro.test(pisa$math[pisa$gender == "male"])
shapiro.test(pisa$math[pisa$gender == "female"])
t.test(pisa$math[pisa$gender == "male"], pisa$math[pisa$gender == "female"],
alternative = "two.sided")
# 1. Boxplot des scores en math selon le sexe
boxplot(read~gender, data = pisa, col = c("pink", "lightblue"))
### 2. Vérification de la normalité par QQ-plot
par(mfrow = c(1,2))  # pour afficher les 2 graphiques côte à côte
# Males
qqnorm(pisa$read[pisa$gender == "male"],
main = "QQ-plot des read (garçons)")
qqline(pisa$read[pisa$gender == "male"])
# Females
qqnorm(pisa$read[pisa$gender == "female"],
main = "QQ-plot des read (filles)")
qqline(pisa$read[pisa$gender == "female"])
# Tests de normalité
shapiro.test(pisa$read[pisa$gender == "male"])
shapiro.test(pisa$read[pisa$gender == "female"])
t.test(pisa$read[pisa$gender == "male"], pisa$read[pisa$gender == "female"],
alternative = "two.sided")
mod_M = lm(read ~ gender, data = pisa)
mod_Y2 = lm(math ~ read + gender, data = pisa)
mod_Y = lm(math ~ gender, data = pisa)
a = coef(mod_M)[2]
b = coef(mod_Y2)[2]
c = coef(mod_Y2)[3]
d = coef(mod_Y)[2]
cat("L’effet direct c est ", round(c, 2), "\n")
cat("L’effet indirect ab est ", round(a * b, 2), "\n")
cat("On a bien d = ab + c =", round(d, 2), "\n")
cat("la p-valeur sur le test de l'effet direct est ",
coef(summary(mod_Y2))[3, 4],
"< 0.05\n")
cat("Les valeurs plausibles de l’effet direct se situent entre [",
round(confint(mod_Y2)["gendermale", 1], 2),
";",
round(confint(mod_Y2)["gendermale", 2], 2),
"]\n")
B <- 5000                     # nombre de réplications bootstrap
ab_values <- numeric(B)
for (i in 1:B) {
# Tirage bootstrap
sample_idx <- sample(1:nrow(pisa), replace = TRUE)
data_b <- pisa[sample_idx, ]
# Modèle médiateur M ~ X
mod_M_b <- lm(read ~ gender, data = data_b)
# Modèle Y ~ M + X
mod_Y2_b <- lm(math ~ gender + read, data = data_b)
# Extraction des coefficients
a_b <- coef(mod_M_b)[2]
b_b <- coef(mod_Y2_b)[2]
ab_values[i] <- a_b * b_b   # effet indirect bootstrap
}
### 2. Vérification de la normalité par QQ-plot
par(mfrow = c(1,2))  # pour afficher les 2 graphiques côte à côte
# Males
qqnorm(pisa$read[pisa$gender == "male"],
main = "QQ-plot des read (garçons)",
col="lightblue")
qqline(pisa$read[pisa$gender == "male"])
# Females
qqnorm(pisa$read[pisa$gender == "female"],
main = "QQ-plot des read (filles)",
col="pink")
qqline(pisa$read[pisa$gender == "female"])
# Tests de normalité
shapiro.test(pisa$read[pisa$gender == "male"])
shapiro.test(pisa$read[pisa$gender == "female"])
### 2. Vérification de la normalité par QQ-plot
par(mfrow = c(1,2))  # pour afficher les 2 graphiques côte à côte
# Males
qqnorm(pisa$read[pisa$gender == "male"],
main = "QQ-plot des read (garçons)",
col="blue")
qqline(pisa$read[pisa$gender == "male"])
# Females
qqnorm(pisa$read[pisa$gender == "female"],
main = "QQ-plot des read (filles)",
col="red")
qqline(pisa$read[pisa$gender == "female"])
# Tests de normalité
shapiro.test(pisa$read[pisa$gender == "male"])
shapiro.test(pisa$read[pisa$gender == "female"])
# Intervalle de confiance bootstrap
IC <- quantile(ab_values, probs =  c(0.025, 0.975))
cat("L'intervalle de confiance est ainsi [", round(IC[1], 2), ";", round(IC[2], 2), "]")
# Intervalle de confiance bootstrap
IC <- quantile(ab_values, probs =  c(0.025, 0.975))
cat("L'intervalle de confiance est ainsi [", round(IC[1], 2), ";", round(IC[2], 2), "]")
# Intervalle de confiance bootstrap
IC <- quantile(ab_values, probs =  c(0.025, 0.975))
cat("L'intervalle de confiance est ainsi [", round(IC[1], 2), ";", round(IC[2], 2), "]")
# Intervalle de confiance bootstrap
IC <- quantile(ab_values, prob =  c(0.025, 0.975))
cat("L'intervalle de confiance est ainsi [", round(IC[1], 2), ";", round(IC[2], 2), "]")
# Intervalle de confiance bootstrap
IC <- quantile(ab_values, prob =  c(0.025, 0.975))
cat("L'intervalle de confiance est ainsi [", round(IC[1], 2), ";", round(IC[2], 2), "]")
IC
IC[1]
B <- 5000                     # nombre de réplications bootstrap
ab_values <- numeric(B)
for (i in 1:B) {
# Tirage bootstrap
sample_idx <- sample(1:nrow(pisa), replace = TRUE)
data_b <- pisa[sample_idx, ]
# Modèle médiateur M ~ X
mod_M_b <- lm(read ~ gender, data = data_b)
# Modèle Y ~ M + X
mod_Y2_b <- lm(math ~ gender + read, data = data_b)
# Extraction des coefficients
a_b <- coef(mod_M_b)[2]
b_b <- coef(mod_Y2_b)[2]
ab_values[i] <- a_b * b_b   # effet indirect bootstrap
}
# Intervalle de confiance bootstrap
IC <- quantile(ab_values, prob =  c(0.025, 0.975))
cat("L'intervalle de confiance est ainsi [", round(IC[1], 2), ";", round(IC[2], 2), "]")
# Intervalle de confiance bootstrap
IC <- quantile(ab_values,  c(0.025, 0.975))
cat("L'intervalle de confiance est ainsi [", round(IC[1], 2), ";", round(IC[2], 2), "]")
# Intervalle de confiance bootstrap
IC <- quantile(ab_values,  c(0.025, 0.975))
cat("L'intervalle de confiance est ainsi [", round(IC[1], 2), ";", round(IC[2], 2), "]")
# Intervalle de confiance bootstrap
IC <- quantile(ab_values,  c(0.025, 0.975))
cat("L'intervalle de confiance est ainsi [", round(IC[1], 2), ";", round(IC[2], 2), "]")
# Intervalle de confiance bootstrap
IC <- quantile(ab_values,  c(0.025, 0.975))
cat("L'intervalle de confiance est ainsi [", round(IC[1], 2), ";", round(IC[2], 2), "]")
PISA2018 <- read.csv("./data/PISA2018subset.csv", stringsAsFactors = TRUE)
# Sélection des pays d’Europe de l’Ouest
pisa <- subset(PISA2018, country %in% c("FRA", "DEU", "BEL", "ITA", "GBR"))
# Sélection des variables d’intérêt
pisa <- pisa[, c("country", "gender", "read", "math", "escs")]
# Suppression des observations avec valeurs manquantes
pisa <- pisa[!(is.na(pisa$read) | is.na(pisa$escs)),]
# Réduction des niveaux de facteur
pisa$country <- droplevels(pisa$country)
head(pisa)
# Presentation des donnees
plot(pisa$read, pisa$math,
cex = .9, col = "red", pch = 19, las = 1,
xlab = "Scores en lecture",
ylab = "Scores en mathématiques",
main = "Relation entre lecture et mathématiques")
# Ajustement du modele de regression lineaire
mod_math_read = lm(math ~ read, data = pisa)
# Résumé du modèle
summary(mod_math_read)
residus = residuals(mod_math_read)
# Histogramme des résidus
hist(residus, main = "Histogramme des résidus", col = "pink")
# QQ-plot
qqnorm(residus)
qqline(residus)
# Defintions
y = pisa$math
x = pisa$read
r.squared = round((cov(x, y)^2)/(var(x)*var(y)), 2)
cat("La part de variance de `math` expliquée par `read` est : ", r.squared, "\n")
cat("Le resume indique que c'est : ", round(summary(mod_math_read)$r.squared, 2), "\n")
# Presentation des donnees
plot(pisa$read, pisa$math,
cex = .9, col = "red", pch = 19, las = 1,
xlab = "Scores en lecture",
ylab = "Scores en mathématiques",
main = "Relation entre lecture et mathématiques")
legend(x = "topleft",
legend = paste("Droite de régression linéaire (R2 = ", r.squared*100, "%)"))
# Droite de tendance
abline(mod_math_read, col = "blue")
b_1 = round(coef(mod_math_read)[2], 2)
b_1_hat = round(cov(x, y)/var(x), 2)
cat("Theoriquement la pente est ", b_1_hat, "\n")
cat("Le resume indique que c'est : ", b_1, "\n")
cat("Leur score moyen en mathématiques sera supérieur à la moyenne générale de : ",
round(b_1 * 10, 2), "points\n")
IC_sup = round(confint(mod_math_read)[2, 2], 2)
IC_inf = round(confint(mod_math_read)[2, 1], 2)
cat("l’intervalle de confiance à 95 % de l’estimation de la pente de la droite \n",
"de régression est : [", IC_inf, "; ", IC_sup, "]\n")
cat("la p-valeur associée au test de significativité de ce coefficient est : ",
coef(summary(mod_math_read))[2, 4], "\n")
b_confusion = round(coef(lm(pisa$math ~ pisa$read + pisa$escs))[3]
* cor(pisa$escs, pisa$read)
* sd(pisa$escs)/sd(pisa$read)
, 2)
cat("Le biais de confusion =", b_confusion, " est non nul\n")
cat("`math` et `escs` ont une correlation de ",
round(cor(pisa$math, pisa$escs), 2), "\n")
cat("L'effet de `escs` sur `math` est ",
round(coef(lm(pisa$math ~ pisa$read + pisa$escs))[3], 2), "\n")
mod_read_et_escs = lm(pisa$math ~ pisa$read + pisa$escs)
b_1 = coef(mod_read_et_escs)[2]
a_1 = coef(mod_math_read)[2]
cat("1) L'effet partiel de `read` sur `math` une fois `escs` pris en compte est ",
b_1, "\n")
cat("2) L'effet partiel de `read` sur `math` sans prise en compte de `escs` est ",
a_1, "\n")
cat("Le bias de confusion est donc ", round(a_1 - b_1, 2), "\n")
cat("La moyenne des scores en `math` est 500, ainsi le biais de confusion est faible.")
# 1. Boxplot des scores en math selon le sexe
boxplot(math~gender, data = pisa, col = c("pink", "lightblue"))
### 2. Vérification de la normalité par QQ-plot
par(mfrow = c(1,2))  # pour afficher les 2 graphiques côte à côte
# Males
qqnorm(pisa$math[pisa$gender == "male"],
main = "QQ-plot des math (garçons)",
col="blue")
qqline(pisa$math[pisa$gender == "male"])
# Females
qqnorm(pisa$math[pisa$gender == "female"],
main = "QQ-plot des math (filles)",
col="red")
qqline(pisa$math[pisa$gender == "female"])
# Tests de normalité
shapiro.test(pisa$math[pisa$gender == "male"])
shapiro.test(pisa$math[pisa$gender == "female"])
t.test(pisa$math[pisa$gender == "male"], pisa$math[pisa$gender == "female"],
alternative = "two.sided")
# 1. Boxplot des scores en math selon le sexe
boxplot(read~gender, data = pisa, col = c("pink", "lightblue"))
### 2. Vérification de la normalité par QQ-plot
par(mfrow = c(1,2))  # pour afficher les 2 graphiques côte à côte
# Males
qqnorm(pisa$read[pisa$gender == "male"],
main = "QQ-plot des read (garçons)",
col="blue")
qqline(pisa$read[pisa$gender == "male"])
# Females
qqnorm(pisa$read[pisa$gender == "female"],
main = "QQ-plot des read (filles)",
col="red")
qqline(pisa$read[pisa$gender == "female"])
# Tests de normalité
shapiro.test(pisa$read[pisa$gender == "male"])
shapiro.test(pisa$read[pisa$gender == "female"])
t.test(pisa$read[pisa$gender == "male"], pisa$read[pisa$gender == "female"],
alternative = "two.sided")
mod_M = lm(read ~ gender, data = pisa)
mod_Y2 = lm(math ~ read + gender, data = pisa)
mod_Y = lm(math ~ gender, data = pisa)
a = coef(mod_M)[2]
b = coef(mod_Y2)[2]
c = coef(mod_Y2)[3]
d = coef(mod_Y)[2]
cat("L’effet direct c est ", round(c, 2), "\n")
cat("L’effet indirect ab est ", round(a * b, 2), "\n")
cat("On a bien d = ab + c =", round(d, 2), "\n")
cat("la p-valeur sur le test de l'effet direct est ",
coef(summary(mod_Y2))[3, 4],
"< 0.05\n")
cat("Les valeurs plausibles de l’effet direct se situent entre [",
round(confint(mod_Y2)["gendermale", 1], 2),
";",
round(confint(mod_Y2)["gendermale", 2], 2),
"]\n")
B <- 5000                     # nombre de réplications bootstrap
ab_values <- numeric(B)
for (i in 1:B) {
# Tirage bootstrap
sample_idx <- sample(1:nrow(pisa), replace = TRUE)
data_b <- pisa[sample_idx, ]
# Modèle médiateur M ~ X
mod_M_b <- lm(read ~ gender, data = data_b)
# Modèle Y ~ M + X
mod_Y2_b <- lm(math ~ read + gender, data = data_b)
# Extraction des coefficients
a_b <- coef(mod_M_b)[2]
b_b <- coef(mod_Y2_b)[2]
ab_values[i] <- a_b * b_b   # effet indirect bootstrap
}
# Intervalle de confiance bootstrap
IC <- quantile(ab_values,  c(0.025, 0.975))
cat("L'intervalle de confiance est ainsi [", round(IC[1], 2), ";", round(IC[2], 2), "]")
install.packages("shiny")
library(shiny)
runExample("01_hello")
shiny::runApp('Desktop/equipe_1/ShinyApp')
runApp('Desktop/equipe_1/ShinyApp')
runApp('Desktop/equipe_1/ShinyApp')
runApp('Desktop/equipe_1/ShinyApp')
runApp('Desktop/equipe_1/ShinyApp')
runApp('Desktop/equipe_1/ShinyApp')
runApp('Desktop/equipe_1/ShinyApp')
runApp('Desktop/equipe_1/ShinyApp')
source('/home/zeroualima/Desktop/equipe_1/ShinyApp/app.R')
runApp('Desktop/equipe_1/ShinyApp')
runApp('Desktop/equipe_1/ShinyApp')
help(plot)
runApp('Desktop/equipe_1/ShinyApp')
runApp('Desktop/equipe_1/ShinyApp')
runApp('Desktop/equipe_1/ShinyApp')
runApp('Desktop/equipe_1/ShinyApp')
runApp('Desktop/equipe_1/ShinyApp')
shiny::runApp('Desktop/equipe_1/ShinyApp')
shiny::runApp('Desktop/equipe_1/ShinyApp')
runApp('Desktop/equipe_1/ShinyApp')
runApp('Desktop/equipe_1/ShinyApp')
runApp('Desktop/equipe_1/ShinyApp')
shiny::runApp('Desktop/equipe_1/ShinyApp')
runApp('Desktop/equipe_1/ShinyApp')
runApp('Desktop/equipe_1/ShinyApp')
df <- read.csv2("/home/elfarchi/equipe_1/Laser.csv")
source("~/Desktop/equipe_1/ShinyApp/sim traj weiner semi_cond.R")
source("~/Desktop/equipe_1/ShinyApp/sim traj weiner semi_cond.R")
source("~/Desktop/equipe_1/ShinyApp/sim traj weiner semi_cond.R")
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
runApp('Desktop/equipe_1/ShinyApp')
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
runApp('Desktop/equipe_1/ShinyApp')
output$csv_stats <- renderPrint({
req(input$show_stats)
df <- data()
t = df[, 1]
a = numeric(ncol(df) - 1)
b = numeric(ncol(df) - 1)
for (i in 1:length(a)) {
X = df[, i + 1]
delta_X = numeric(nrow(df))
delta_X[1] = X[1]
for (j in 2:length(delta_X)) {
delta_X[i] = X[i] - X[i - 1]
}
m = mean(delta_X)
v = variance(delta_X)
a[i] = m/v
b[i] = t[length(t)]/v
}
print(a)
runApp('Desktop/equipe_1/ShinyApp')
runApp('Desktop/equipe_1/ShinyApp')
cg
c
for (i in 1:length(a)) {
X = df[, i + 1]
delta_X = numeric(nrow(df))
delta_X[1] = X[1]
for (j in 2:length(delta_X)) {
delta_X[i] = X[i] - X[i - 1]
}
m = mean(delta_X)
v = variance(delta_X)
a[i] = m/v
b[i] = t[length(t)]/v
}
jbfdce
shiny::runApp('Desktop/equipe_1/ShinyApp')
shiny::runApp('Desktop/equipe_1/ShinyApp')
shiny::runApp('Desktop/equipe_1/ShinyApp')
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
runApp('Desktop/equipe_1/ShinyApp')
library(shiny); runApp('Desktop/equipe_1/ShinyApp/app_test.R')
library(shiny); runApp('Desktop/equipe_1/ShinyApp/app_test.R')
runApp('Desktop/equipe_1/ShinyApp/app_mod.R')
runApp('Desktop/equipe_1/ShinyApp')
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
source("~/Desktop/equipe_1/ShinyApp/plusieurs trajectoires.R")
source("~/Desktop/equipe_1/ShinyApp/plusieurs trajectoires.R")
source("~/Desktop/equipe_1/ShinyApp/plusieurs trajectoires.R")
source("~/Desktop/equipe_1/ShinyApp/plusieurs trajectoires.R")
source("~/Desktop/equipe_1/ShinyApp/plusieurs trajectoires.R")
source("~/Desktop/equipe_1/ShinyApp/plusieurs trajectoires.R")
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
source("~/Desktop/equipe_1/ShinyApp/simulation_gamma _moments.R")
source("~/Desktop/equipe_1/ShinyApp/estimation gamma.R")
source("~/Desktop/equipe_1/ShinyApp/estimation gamma.R")
source("~/Desktop/equipe_1/ShinyApp/estimation gamma.R")
source("~/Desktop/equipe_1/ShinyApp/estimation gamma.R")
source("~/Desktop/equipe_1/ShinyApp/estimation gamma.R")
source("~/Desktop/equipe_1/ShinyApp/estimation gamma.R")
source("~/Desktop/equipe_1/ShinyApp/estimation gamma.R")
source("~/Desktop/equipe_1/ShinyApp/estimation gamma.R")
runApp('Desktop/equipe_1/ShinyApp')
source("~/Desktop/equipe_1/ShinyApp/estimation gamma.R")
runApp('Desktop/equipe_1/ShinyApp')
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
source("~/Desktop/equipe_1/ShinyApp/estimation gamma.R")
source("~/Desktop/equipe_1/ShinyApp/estimation gamma.R")
source("~/Desktop/equipe_1/ShinyApp/estimation gamma.R")
source("~/Desktop/equipe_1/ShinyApp/estimation gamma.R")
source("~/Desktop/equipe_1/ShinyApp/simulation_weiner_moments.R")
runApp('Desktop/equipe_1/ShinyApp')
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
source("~/Desktop/equipe_1/ShinyApp/simulation_weiner_moments.R")
source("~/Desktop/equipe_1/ShinyApp/estimation weiner.R")
source("~/Desktop/equipe_1/ShinyApp/plusieurs trajectoires.R")
source("~/Desktop/equipe_1/ShinyApp/sim traj weiner semi_cond.R")
source("~/Desktop/equipe_1/ShinyApp/sim traj weiner semi_cond.R")
source("~/Desktop/equipe_1/ShinyApp/plusieurs trajectoires.R")
source("~/Desktop/equipe_1/ShinyApp/sim traj weiner semi_cond.R")
runApp('Desktop/equipe_1/ShinyApp')
runApp('Desktop/equipe_1/ShinyApp')
shiny::runApp('Desktop/equipe_1/ShinyApp')
runApp('Desktop/equipe_1/ShinyApp')
